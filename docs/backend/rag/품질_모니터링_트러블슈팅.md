# 임베딩 품질 모니터링 트러블슈팅 가이드

**작성일**: 2026-01-06  
**프로젝트**: 똑소리 (ddoksori_demo)  
**관련 파일**: `backend/scripts/embedding/embed_data_remote.py`

---

## 📋 목차

1. [개요](#개요)
2. [품질 검증 기준](#품질-검증-기준)
3. [저품질 임베딩 감지 및 해결](#저품질-임베딩-감지-및-해결)
4. [통계 확인 방법](#통계-확인-방법)
5. [일반적인 문제와 해결책](#일반적인-문제와-해결책)
6. [모니터링 스크립트 사용법](#모니터링-스크립트-사용법)

---

## 개요

임베딩 품질 모니터링 기능은 RAG 시스템의 검색 정확도를 보장하기 위해 추가되었습니다. 이 기능은 임베딩 생성 시 자동으로 품질을 검증하고, 저품질 임베딩을 감지하여 보고합니다.

### 주요 기능

- ✅ 실시간 임베딩 품질 검증
- ✅ 저품질 임베딩 자동 감지
- ✅ 상세한 품질 통계 제공
- ✅ 데이터베이스 검증 시 품질 분석

---

## 품질 검증 기준

임베딩 품질 검증은 다음 4가지 기준을 사용합니다:

### 1. Norm (벡터 크기) 체크

**기준**: 벡터의 L2 norm이 0.1 미만이면 저품질로 판단

```python
norm = np.linalg.norm(vec)
if norm < 0.1:
    return True, "norm이 너무 작음"
```

**의미**: 벡터의 크기가 너무 작으면 의미 있는 정보를 담지 못한 것으로 간주됩니다.

**일반적인 원인**:
- 빈 텍스트 또는 의미 없는 텍스트
- 임베딩 모델의 오류
- 정규화 과정의 문제

### 2. 분산 (Variance) 체크

**기준**: 벡터의 분산이 0.001 미만이면 저품질로 판단

```python
variance = np.var(vec)
if variance < 0.001:
    return True, "분산이 너무 작음"
```

**의미**: 모든 값이 유사하면 벡터가 구별력을 잃어 검색 정확도가 떨어집니다.

**일반적인 원인**:
- 반복적인 텍스트 패턴
- 동일한 내용의 청크
- 임베딩 모델의 한계

### 3. NaN/Inf 값 체크

**기준**: 벡터에 NaN(Not a Number) 또는 Inf(Infinity) 값이 포함되면 저품질로 판단

```python
if np.isnan(vec).any() or np.isinf(vec).any():
    return True, "NaN 또는 Inf 값 포함"
```

**의미**: 잘못된 수치 값은 벡터 연산 시 오류를 발생시킵니다.

**일반적인 원인**:
- 임베딩 모델의 버그
- 수치 연산 오류
- 데이터 처리 과정의 문제

### 4. 희소성 (Sparsity) 체크

**기준**: 벡터의 90% 이상이 0에 가까우면 저품질로 판단

```python
near_zero = np.abs(vec) < 0.001
if near_zero.sum() / len(vec) > 0.9:
    return True, "희소 벡터"
```

**의미**: 대부분의 값이 0에 가까우면 정보 밀도가 낮아 검색 성능이 저하됩니다.

**일반적인 원인**:
- 특정 임베딩 모델의 특성
- 정규화 과정의 문제
- 짧은 텍스트로 인한 정보 부족

---

## 저품질 임베딩 감지 및 해결

### 실시간 모니터링

임베딩 생성 중 자동으로 품질을 검증합니다:

```bash
# 임베딩 스크립트 실행
conda activate ddoksori
cd /home/maroco/ddoksori_demo/backend
python scripts/embed_data_remote.py
```

**출력 예시**:

```
🔮 임베딩 생성: 1000개 청크

⚠️  저품질 임베딩 감지: chunk_12345
  이유: norm이 너무 작음 (0.0234)
  텍스트 길이: 5자
  텍스트 미리보기: "주 문"...

✅ 1000개 청크 임베딩 완료
⚠️  저품질 임베딩: 15개 (1.5%)
```

### 통계 확인

임베딩 완료 후 통계에서 품질 정보를 확인할 수 있습니다:

```
📊 처리 완료 통계
================================================================================
문서:                 12,150개
청크 (삽입):          14,898개
청크 (스킵/drop):     92개
청크 (빈 content):    0개
임베딩 생성:          14,806개
저품질 임베딩:        15개 (0.1%)

⚠️  품질 경고: 15개
  저품질 임베딩 감지: chunk_12345
    이유: norm이 너무 작음 (0.0234)
    텍스트 길이: 5자
    텍스트 미리보기: "주 문"...
  ... 외 14개
```

---

## 통계 확인 방법

### 1. 스크립트 실행 시 자동 통계

임베딩 스크립트 실행 후 자동으로 통계가 출력됩니다.

### 2. 데이터베이스 검증 시 품질 분석

`verify_data()` 메서드를 통해 샘플링 기반 품질 분석을 수행합니다:

```python
pipeline = EmbeddingPipeline(db_config, embed_api_url)
pipeline.connect_db()
pipeline.verify_data()
```

**출력 예시**:

```
🔍 임베딩 품질 분석 (샘플 100개):
  샘플 크기:          100개
  저품질 임베딩:      2개
  저품질 비율:        2.0%
  주요 이슈:
    - norm이 너무 작음: 1개
    - 분산이 너무 작음: 1개
```

### 3. 데이터베이스 직접 조회

PostgreSQL에서 직접 품질 통계를 확인할 수 있습니다:

```sql
-- 저품질 임베딩 샘플 확인 (수동 계산 필요)
SELECT 
    chunk_id,
    doc_id,
    content_length,
    LEFT(content, 100) as content_preview
FROM chunks
WHERE embedding IS NOT NULL
  AND drop = FALSE
ORDER BY content_length ASC
LIMIT 10;
```

---

## 일반적인 문제와 해결책

### 문제 1: "norm이 너무 작음" 경고가 많이 발생

**증상**:
```
⚠️  저품질 임베딩: 150개 (10.0%)
  주요 이슈: norm이 너무 작음
```

**원인**:
- 빈 텍스트 또는 매우 짧은 텍스트 (예: "주 문", "다. 결론")
- 의미 없는 텍스트 청크

**해결책**:

1. **데이터 변환 단계에서 필터링**:
   ```python
   # data_transform_pipeline.py에서
   if len(content.strip()) < 10:
       chunk['drop'] = True  # 임베딩 제외
   ```

2. **청크 병합**:
   - 짧은 청크를 이전/다음 청크와 병합하여 의미 있는 단위로 만들기

3. **최소 길이 설정**:
   - 변환 스크립트에서 최소 길이를 100자 이상으로 설정

### 문제 2: "분산이 너무 작음" 경고 발생

**증상**:
```
⚠️  저품질 임베딩 감지
  이유: 분산이 너무 작음 (0.000234)
```

**원인**:
- 반복적인 텍스트 패턴
- 동일한 내용의 청크가 많음
- 특정 문서 타입의 특성

**해결책**:

1. **청크 내용 확인**:
   ```sql
   SELECT chunk_id, content
   FROM chunks
   WHERE chunk_id = '문제_청크_ID';
   ```

2. **중복 청크 제거**:
   - 동일한 내용의 청크가 있는지 확인
   - 필요시 데이터 변환 단계에서 중복 제거

3. **청크 타입별 처리**:
   - 특정 타입의 청크가 반복 패턴을 가지는 경우, 별도 처리 로직 적용

### 문제 3: "NaN 또는 Inf 값 포함" 경고 발생

**증상**:
```
⚠️  저품질 임베딩 감지
  이유: NaN 또는 Inf 값 포함
```

**원인**:
- 임베딩 모델의 버그
- API 서버의 문제
- 네트워크 오류로 인한 불완전한 응답

**해결책**:

1. **임베딩 API 확인**:
   ```bash
   # API 서버 상태 확인
   curl http://localhost:8001/health
   ```

2. **재시도 로직**:
   - 임베딩 스크립트에 자동 재시도 로직 추가
   - 실패한 청크만 다시 임베딩 생성

3. **API 서버 재시작**:
   ```bash
   # RunPod 서버 재시작
   ssh user@runpod-server
   cd /workspace
   uvicorn runpod_embed_server:app --host 0.0.0.0 --port 8000
   ```

### 문제 4: "희소 벡터" 경고 발생

**증상**:
```
⚠️  저품질 임베딩 감지
  이유: 희소 벡터 (768/768 값이 ~0)
```

**원인**:
- 특정 임베딩 모델의 특성
- 정규화 과정의 문제
- 짧은 텍스트로 인한 정보 부족

**해결책**:

1. **텍스트 길이 확인**:
   - 짧은 텍스트는 병합하거나 제외

2. **임베딩 모델 확인**:
   - 사용 중인 모델이 희소 벡터를 생성하는 특성이 있는지 확인
   - 필요시 다른 모델로 변경 검토

3. **정규화 설정 확인**:
   - 임베딩 모델의 정규화 옵션 확인

---

## 모니터링 스크립트 사용법

### 기본 사용법

```bash
# 1. 환경 준비
conda activate ddoksori
cd /home/maroco/ddoksori_demo/backend

# 2. 환경 변수 확인
cat .env
# EMBED_API_URL=http://localhost:8001/embed

# 3. 임베딩 실행 (자동으로 품질 모니터링 포함)
python scripts/embed_data_remote.py
```

### 특정 파일만 처리

```python
from pathlib import Path
from backend.scripts.embed_data_remote import EmbeddingPipeline
import os

# 환경 변수 로드
db_config = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': int(os.getenv('DB_PORT', 5432)),
    'database': os.getenv('DB_NAME', 'ddoksori'),
    'user': os.getenv('DB_USER', 'postgres'),
    'password': os.getenv('DB_PASSWORD', 'postgres')
}

embed_api_url = os.getenv('EMBED_API_URL', 'http://localhost:8001/embed')

# 파이프라인 생성
pipeline = EmbeddingPipeline(db_config, embed_api_url)
pipeline.connect_db()

# 특정 파일 처리
json_file = Path("backend/data/transformed/mediation_kca.json")
pipeline.process_json_file(json_file)

# 통계 확인
pipeline.print_stats()
pipeline.close_db()
```

### 품질 분석만 수행

```python
# 이미 임베딩이 완료된 데이터에 대해 품질 분석만 수행
pipeline = EmbeddingPipeline(db_config, embed_api_url)
pipeline.connect_db()
pipeline.verify_data()  # 품질 분석 포함
pipeline.close_db()
```

---

## 품질 임계값 조정

필요에 따라 품질 검증 기준을 조정할 수 있습니다:

```python
# embed_data_remote.py의 is_low_quality_embedding 메서드 수정

def is_low_quality_embedding(self, embedding: List[float]) -> Tuple[bool, str]:
    vec = np.array(embedding)
    
    # 더 엄격한 기준 (기본값보다 높은 임계값)
    norm = np.linalg.norm(vec)
    if norm < 0.2:  # 기본값: 0.1
        return True, f"norm이 너무 작음 ({norm:.4f})"
    
    variance = np.var(vec)
    if variance < 0.01:  # 기본값: 0.001
        return True, f"분산이 너무 작음 ({variance:.6f})"
    
    # ... 나머지 체크
```

**권장 사항**:
- 기본 임계값은 일반적인 RAG 사용 사례에 최적화되어 있습니다
- 특정 도메인이나 모델에 맞게 조정이 필요할 수 있습니다
- 조정 후 충분한 테스트를 통해 검색 성능을 확인하세요

---

## 관련 문서

- [데이터 변환 및 테스트 가이드](./데이터_변환_및_테스트_가이드.md)
- [청킹 및 임베딩 결과 확인 가이드](./청킹%20및%20임베딩%20결과%20확인%20가이드.md)
- [RAG 데이터 품질 개선 계획](../.cursor/plans/데이터_품질_개선_계획_22a4ef1e.plan.md)

---

## 문제 보고

품질 모니터링 중 발견된 문제는 다음 정보와 함께 보고해주세요:

1. **에러 메시지**: 전체 에러 메시지
2. **통계 정보**: 저품질 임베딩 개수 및 비율
3. **샘플 청크**: 문제가 발생한 청크 ID 및 내용
4. **환경 정보**: 
   - 임베딩 모델 버전
   - Python 버전
   - 데이터베이스 버전

---

**마지막 업데이트**: 2026-01-06
